#pragma config(Sensor, S2,     lightArriere,        sensorLightActive)
#pragma config(Sensor, S1,     lightAvant,          sensorLightActive)
#pragma config(Motor,  motorA,          motorGauche,          tmotorNxtEncoderClosedLoop)
#pragma config(Motor,  motorB,          motorDroit,           tmotorNxtEncoderClosedLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int equilibre = 0;

int erreur = 0;
int lastErreur = 0;
int accuErreur = 0;
int diffErreur = 0;

// on gere un buffer d'erreurs pour avoir un accumulateur glissant sur les n dernieres valeurs
const int bufferSize = 20;
int bufferIndex = 0;
int bufferErreur[bufferSize];

const int coeffP = 1;
const int coeffI = 0;
const int coeffD = 0;

task main()
{
	//
	eraseDisplay();

	// init the array to value 0
	for (int i=0; i<bufferSize; i++) {
	  bufferErreur[i] = 0;
	}

	//
	nxtDisplayBigTextLine(2, "Attendre 2 sec...");
	wait1Msec(1000);
	//
	equilibre = SensorRaw[lightArriere]-SensorRaw[lightAvant];
	//
	wait1Msec(1000);
	eraseDisplay();



	while(true) {
  	//
	  nxtDisplayCenteredTextLine(0, "avant :\t%d",SensorRaw[lightAvant],0);

		nxtDisplayCenteredTextLine(1, "arriere :\t%d",SensorRaw[lightArriere],0);

  	nxtDisplayTextLine(3, "err :\t%d",erreur,0);
  	nxtDisplayTextLine(4, "acc :\t%d",accuErreur,0);
  	nxtDisplayTextLine(5, "dif :\t%d",diffErreur,0);

  	//
		wait1Msec(100);

		// calcul de l'erreur nouvelle
		erreur = SensorRaw[lightArriere]-SensorRaw[lightAvant];
		// calcul de l'accumulation
		accuErreur -= bufferErreur[bufferIndex];
		accuErreur += erreur;
		bufferErreur[bufferIndex] = erreur;

		bufferIndex++;
		if (bufferIndex >= bufferSize)
		{
		  bufferIndex = 0;
		}

		// calcul de la difference
		diffErreur = erreur - lastErreur;
		lastErreur = erreur;

		if (erreur > 0)
		{
      motor[motorGauche] = coeffP*erreur + coeffI*accuErreur + coeffD*diffErreur;
      motor[motorDroit] = coeffP*erreur + coeffI*accuErreur + coeffD*diffErreur;
		} else if (erreur < 0)
		{
      motor[motorGauche] = coeffP*erreur + coeffI*accuErreur + coeffD*diffErreur;
      motor[motorDroit] = coeffP*erreur + coeffI*accuErreur + coeffD*diffErreur;
		} else {
      motor[motorGauche] = 0;
      motor[motorDroit] = 0;
		}



	}

}
